## Part 1. Установка ОС

> *Узнаем версию* Ubuntu, выполнив команду: `cat /etc/issue` .

![version_ubuntu](images/P1_p001.png)

## Part 2. Создание пользователя

> Основная пользовательская информация находится в файле ` /etc/passwd ` .
> Это текстовый файл, который содержит важную информацию о каждом пользователе.

> Когда мы создаем нового пользователя, новые данные пользователя будут добавлены в этот файл. При создании новых пользователей следующие четыре файла будут изменены:
> - ` /etc/passwd ` : информация о пользователе будет обновлена ​​в этом файле.
> - ` /etc/shadow `: информация о пароле пользователя будет обновлена ​​в этом файле.
> - ` /etc/group `: информация о группе будет обновлена ​​для нового пользователя в этом файле.
> - ` /etc/gshadow `: информация о пароле группы будет обновлена ​​для нового пользователя в файле.

> Создать пользователя можно с помощью одной из трёх следующих команд:
> - ` useradd `: создать нового пользователя или обновить информацию о новом пользователе по умолчанию.
> - ` adduser `: создать нового пользователя со всеми параметрами по умолчанию или обновить информацию о новом пользователе.
> - ` newusers `: обновить и создать новых пользователей в пакетном режиме.

> Удалить пользователя можно с помощью следующей команды: ` sudo deluser username ` .

> Создаем нового пользователя с помощью команды: ` sudo useradd -s /bin/bash genesiss ` .

![create user](images/P2_p001.png)

> Проверяем информацию о пользователе с помощью команды: ` cat /etc/passwd ` .
> Можно проверить с использованием grep командой: ` cat /etc/passwd | grep genesiss ` .

![check user](images/P2_p002.png)

> Создаём пароль для пользователя genesiss: ` sudo passwd genesiss ` .

![create password](images/P2_p003.png)

> Добавляем пользователя в группы adm и sudo для предоставления прав на прочтение логов из папки /var/log: ` sudo usermod -G adm,sudo genesiss ` .

![add_to_group](images/P2_p004.png)

## Part 3. Настройка сети ОС

Сначала следует прочесть про сетевые интерфейсы и [DHCP](https://selectel.ru/blog/dhcp-protocol/ "Принципы работы протокола DHCP"). Также можно прочитать информацию

> Какие порты использует DHCP? Сервер всегда слушает **67 порт**, ожидает широковещательное сообщение от клиента, а после его получения отправляет ответное предложение — DHCPOFFER. Клиент принимает сообщение на **68 порту**.

> ` hostname ` — это имя, которое присваивается компьютеру, подключенному к сети, которое однозначно идентифицирует в сети и, таким образом, позволяет получить доступ к нему без использования его IP-адреса.

> Чтобы проверить какое имя хоста установлено, можно воспользоваться командой: ` hostname ` .

![get hostname](images/P3_p001.png)

> Задаем название машины вида *user-1* с помощью команды: ` sudo hostname user-1 ` .(изменения действуют до первой перезагрузки)

![change hostname](images/P3_p002.png)
![hostname after restart](images/P3_p003.png)

> Чтобы изменить имя навсегда, используем команду: ` sudo hostnamectl set-hostname user-1 ` .

![change hostname forever](images/P3_p004.png)

> После перезагрузки VirtualBox.

![hostname after restart](images/P3_p005.png)

> Проверяем какая временная зона установлена с помощью команды: ` date ` .

![get timezone](images/P3_p006.png)

> Выводим все виды времени: ` timedatectl ` .

![timezone](images/P3_p007.png)

> Определяем временную зону: ` timedatectl list-timezones ` . 

![timezone list](images/P3_p008.png)

> Для установки нужной временной зоны вводим команду: ` sudo timedatectl set-timezone Asia/Novosibirsk ` .

![timezone](images/P3_p009.png)
![get timezone](images/P3_p010.png)

> Для вывода названия сетевых интерфейсов используем команду: ` ifconfig ` . Однако эта команда уже считатется устаревшей и далее рекомендуется применять команду: ` ip address ` или ` ip addr ` или ` ip a `. О том как узнать ip-адрес можно прочитать в [статье](https://pingvinus.ru/note/determine-ip-address "Как узнать ip-адрес.").

![network_interface](images/P3_p011.png)

> Интерфейс lo (loopback device) - это виртуальный интерфейс, присутствующий по умолчанию в любом Linux. Он используется для отладки сетевых программ и запуска серверных приложений на локальной машине. С этим интерфейсом всегда связан адрес 127.0.0.1. С помощью данного адреса программы могут обмениваться трафиком. У него есть dns-имя – localhost. Посмотреть привязку можно в файле /etc/hosts.
> Вывод с помощью другой команды: ` ip link show ` .

![network_interface2](images/P3_p012.png)

> Используя консольную команду ` hostname -I ` получаем ip адрес устройства, на котором работаем, от DHCP сервера. DHCP - это сетевой протокол, используемый для автоматического получения узлами IP-адресов и сетевой конфигурации с сервера. Для просмотра IP-адресов также можно использовать команду: ` ip r ` или ` ip route ` .

![ip_address](images/P3_p013.png)

> внешний ip-адрес шлюза (ip) ` 10.0.2.15 `, внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw) ` 10.0.2.2 `, вывод возможен с помощью команды: ` ip route | grep default ` .

![ip_address-in_out](images/P3_p014.png)

> Можно использовать опцию ` -n ` с командой ` route ` для отображения таблицы маршрутизации с IP-адресами. Флаги U означает, что маршрут «вверх», а G означает, что это шлюз.

![ip_address-in_out](images/P3_p015.png)

> [Для ручной настройки](https://help.ubuntu.ru/wiki/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%D1%81%D0%B5%D1%82%D0%B8_%D0%B2%D1%80%D1%83%D1%87%D0%BD%D1%83%D1%8E "Настройка сети вручную") проверяем подключённые сетевые устройства. Для настроек обязательно потребуется имя сетевого адаптера. Его можно узнать из вывода команды: ` sudo lshw -C network ` . Она позволяет посмотреть подключенные сетевые устройства.

![ip_address-in_out](images/P3_p016.png)
![ip_address-in_out](images/P3_p017.png)

Перед дальнейшей работой следует ознакомиться со статьями ([первая](https://losst.ru/spisok-setevyh-interfejsov-linux), [вторая](https://losst.ru/nastrojka-seti-iz-konsoli-ubuntu)).

> Используем команду ` sudo nano /etc/netplan/00-installer-config.yaml ` для установки статического адреса. Меняем 

![changes](images/P3_p018.png)

> на

![changes](images/P3_p019.png)

> Сохраняем изменения в файле Ctrl+X, выполняем команду ` sudo netplan apply ` .
> Проверяем установленные настройки: ` ip r ` .

![settings](images/P3_p020.png)

> Проверяем установленные настройки dns: `systemd-resolve --status` .

![settings](images/P3_p021.png)
![settings](images/P3_p022.png)

> Пинугем по 5 раз удаленные хосты 1.1.1.1: ` ping -c 5 1.1.1.1` . ya.ru: ` ping -c 5 ya.ru ` .

![check](images/P3_p023.png)
![check](images/P3_p024.png)

## Part 4. Обновление ОС

> До обновления системных пакетов до последней версии используем команду, которая обновит информацию о пакетах, содержащихся в репозиториях для получения самых последних версий пакетов: ` sudo apt-get update` .

![update](images/P4_p001.png)

> Обновляем версию с помощью команды: ` sudo apt-get dist-upgrade ` . В процессе обновления необходимо будет подтвердить обновление.

![update is done](images/P4_p002.png)

> Повторный вызов команды покажет, что нечего обновлять.

![update is done](images/P4_p003.png)

## Part 5. Использование команды sudo

Про то как разрешить пользователю выполнять команду sudo, можно прочитать в этой [статье](https://1cloud.ru/help/linux/nastrojka-prav-polzovatelej-na-ubuntu "Разграничение прав пользователей в Ubuntu").

> Команда ` sudo ` (англ. **S**ubstitute **U**ser and **DO**, дословно «подменить пользователя и выполнить») позволяет пользователям выполнять указанные программы с привилегиями суперпользователя, без введения пароля суперпользователя (root). Если быть точнее, то команда sudo позволяет выполнять программы от имени любого пользователя, но, если идентификатор или имя этого пользователя не указаны, то предполагается выполнение от имени суперпользователя root. Таким образом, использование sudo позволяет выполнять привилегированные команды обычным пользователям без необходимости ввода пароля суперпользователя root. Более подробно можно прочитать в [описании команды](https://white55.ru/sudo.html "man sudo").

> Для переключения на созданного пользователя используется команда: ` su genesiss ` .

![switch to new user](images/P5_p001.png)

> Добавление пользователя в группу, которая позволяет пользователю применять команду sudo: ` sudo usermod -a -G sudo genesiss ` .

![sudo user](images/P5_p002.png)

> Меняем hostname от имени созданного пользователя, которому дали права sudo

![change namehost](images/P5_p003.png)

## Part 6. Установка и настройка службы времени

> В этой части настроивается служба автоматической синхронизации времени.

> Посмотреть какое время установлено возможно введя команду: ` date ` .

![time](images/P6_p001.png)

> Команда ` timedatectl show ` выведет более подробную информацию о времени и дате.

![time](images/P6_p002.png)

## Part 7. Установка и использование текстовых редакторов

> Для работы с редактором **MCEDIT** потребуется его установка. Установить его можно с помощью команды: ` sudo apt -y install mc ` .

> Создать файл можно с помощью команды: `touch filename.txt ` ,
> где ` filename.txt ` - имя файла с расширением. 

![создание файла test_vim.txt](images/P7_p001.png)

---

> Для работы в тестовом редакторе **VIM** используем команду: ` sudo vim test_vim.txt ` .

> Чтобы начать ввод текста в vim, необходимо нажать ` i ` *-insert-*. После завершения ввода текста, необходимо нажать клавишу ` esc `, чтобы выйти из режима *-insert-*.
> Для сохранения изменений и выхода из vim необходимо ввести: ` :wq ` .

![vim edit and save](images/P7_p002.png)

> Открываем файл, вносим изменения и выходим без сохранения: ` :q! ` .

![vim edit without save](images/P7_p003.png)

> Для поиска слов в редакторе vim по файлу используем команду:  ` /searchname ` .

![vim search](images/P7_p004.png)

> Для замены найденного слова используем команду: ` %s/searchname/replacename/g ` . Символ ` % ` означает что обрабатывать нужно весь файл, а ` g ` значит, что нужно обработать все найденные строки, а не только первую. Чтобы программа спрашивала перед каждой заменой можно добавить в конец строки опцию ` c `.

![vim replace](images/P7_p005.png)

---

> Для начала работы с файлом *test_nano.txt* в текстовом редакторе **NANO** используется команда ` sudo nano test_nano.txt `. После изменения файла, сохранить его можно (без запроса на сохранение) нажав сочетание клавиш  ` Ctrl + "O" ` . Выйти с запросом на сохранение, можно с помощью сочетания клавиш ` Ctrl + "X" `. Если изменения не были сохранены, при выходе программа предложит сохранить данные.

![nano edit and save](images/P7_p006.png)

> Снова открываем файл, редактируем, но выходим без сохранения ` Ctrl+X `.

![nano edit without save](images/P7_p007.png)

> Команда ` Ctrl + W ` используется для поиска слов в редакторе. Курсор переместится на первое вхождение (относительно курсора) искомого текста, чтобы продолжить поиск, нажмите сочетание клавиш ` Alt + W ` или ` option + W ` и курсор переместится к следующему вхождению.

![nano search](images/P7_p008.png)

> Замена найденного слова возможна с помощью ` Ctrl+\ ` .

![nano replace1](images/P7_p009.png)
![nano replace2](images/P7_p010.png)
![nano replace3](images/P7_p011.png)
![nano replace4](images/P7_p012.png)
![nano replace5](images/P7_p013.png)

---

> Для начала работы с файлом *test_mcedit.txt* в текстовом редакторе **MCEDIT** используется команда ` sudo mcedit test_mcedit.txt `. 
> Для сохранения быстро нажимаем по очереди ` ESC ` потом ` 2 ` выбираем "Save", либо сохранить при выходе из редактора ` ESC ` потом ` 0 ` .

![mcedit edit and save](images/P7_p014.png) 

> Снова заходим в редактор, вносим изменения, выходим без сохранения ` ESC ` потом ` 0 ` . Выбираем "No".

![mcedit edit without save](images/P7_p015.png)

> Поиск в редакторе осуществляется с помощью ` ESC ` потом ` 7 ` .

![mcedit search 1](images/P7_p016.png)
![mcedit search 2](images/P7_p017.png)

> Замена слова в редакторе осуществляется с помощью ` ESC ` потом ` 4 ` .

![mcedit replace1](images/P7_p018.png)
![mcedit replace2](images/P7_p019.png)
![mcedit replace3](images/P7_p020.png)

## Part 8. Установка и базовая настройка сервиса SSHD

> Для начала работы устанавливаем ` ssh ` . Для его установки используется команда ` sudo apt install ssh ` .
Далее выполняем следующую команду ` sudo apt install openssh-server `, чтобы установить SSH-сервер в системе Ubuntu.

![openssh-install](images/P8_p001.png)

> После завершения загрузки и установки пакета служба SSH должна быть уже запущена, но для уверенности мы проверим ее с помощью ` service ssh status ` либо ` sudo systemctl status ssh ` .

![ssh-status](images/P8_p002.png)

> Добавить сервис в автозагрузку можно с помощью опции enable ` sudo systemctl enable ssh ` .

![ssh add auto](images/P8_p003.png)
 
> Проверяем изменения ` systemctl is-enabled sshd `

![check ssh add auto](images/P8_p004.png)

> Чтобы изменить порт открываем файл ` sudo nano /etc/ssh/sshd_config ` и меняем номер порта на **2022**

![change portname 1](images/P8_p005.png)
![change portname 2](images/P8_p006.png)

> Перезапускаем службу с помощью команды ` sudo systemctl restart sshd `. Порт изменился на 2022. 

![restart sshd](images/P8_p007.png)

> Проверяем наличие процесса sshd с помощью команды ` ps -ef | grep sshd`. 
>  ` е ` выводит информацию обо всех активных процессах. По умолчанию выводится 4 столбца PID, TTY, Time, Command. 
> ` f ` выводит больше информации о запущенных процессах:
> * UID - *пользователь, от имени которого запущен процесс*;
> * PID - *идентификатор процесса*;
> * PPID - *идентификатор родительского процесса*;
> * C - *процент времени CPU, используемого процессом*;
> * STIME - *время запуска процесса*;
> * TTY - *терминал, из которого запущен процесс*;
> * TIME - *общее время процессора, затраченное на выполнение процессора*;
> * CMD - *команда запуска процессора*;

> Утилита ` grep ` помогает фильтровать результаты из команды ps. 

![ps sshd](images/P8_p008.png)

> Инструмент ` netstat ` используется для вывода сведений о сетевых соединениях и таблицах маршрутизации, данных о работе сетевых интерфейсов, о masquerade-соединениях, об элементах групп многоадресной рассылки. 
> ` a (all) ` - для вывода сведений обо всех портах и соединениях, вне зависимости от их состояния и от используемого протокола. 
> ` t (tcp) ` - для вывода сведений обо всех TCP-портах. 
> ` n (numeric)` - выводит числовые адреса, не пытаясь определить символьное имя узла, порт или имя пользователя (запрещает использование псевдонима).

![netstat](images/P8_p009.png)

> * Proto: *Протокол (tcp, udp, raw), используемый сокетом*;
> * recv-Q: *Счётчик байт, не скопированных программой пользователя из этого сокета*;
> * send-Q: *Счётчик байтов, не подтверждённых удалённым узлом*;
> * Local address: *Адрес и номер порта локального конца сокета. Если не указана опция --numeric (-n), адрес сокета преобразуется в каноническое имя узла (FQDN), и номер порта преобразуется в соответствующее имя службы*;
> * Foreign address: *Адрес и номер порта удалённого конца сокета. Аналогично "Local Address"*, 0.0.0.0:* - означает, что процесс привязан ко всем интерфейсам*.


## Part 9. Установка и использование утилит top, htop

> По выводу команды ` top `:
> * uptime **5:01**
> * количество авторизованных пользователей **1 user** 
> * общая загрузка системы **0.00, 0.01, 0.00**
> * общее количество процессов **117** 
> * загрузка cpu **0.0 us**
> * загрузка памяти **221 mb**
> * pid процесса занимающего больше всего памяти **634 (2.7%)**
> * pid процесса, занимающего больше всего процессорного времени **1**

> Выход осуществляется по команде ` q `

![top](images/P9_p001.png)

> Команда ` htop ` выполняет примерно ту же задачу, что и top, но имеет определённые преимущества и недостатки: более удобные поиск и фильтрация, но менее гибкая настройка отображения процессов. Выбор варианта сортировки ввыполняется после нажатия клавиши ` F6 `.

> * сортировка по ` PID `:

![htop PID1](images/P9_p002.png)

> * сортировка по ` PERCENT_CPU `:

![htop CPU](images/P9_p003.png)

> * сортировка по ` PERCENT_MEM `:

![htop MEM](images/P9_p004.png)

> * сортировка по ` TIME `:

![htop TIME](images/P9_p005.png)

> * фильтр для процесса *sshd* (после нажатия ` \ ` в строке *Filter* ввести *sshd*):

![htop filter](images/P9_p006.png)

> * с процессом *syslog*, найденным, используя поиск (` F3 `):

![htop serch1](images/P9_p007.png)

> * с добавленным выводом *hostname*, *clock* и *uptime* (через настройки ` F2 ` добавляем нужные пункты):

![htop input 1](images/P9_p008.png)
![htop input 2](images/P9_p009.png)

## Part 10. Использование утилиты fdisk

> Запускаем команду ` sudo fdisk -l /dev/sda `(` fdisk -l ` отображает все доступные диски).
> * название жесткого диска **/dev/sda**;
> * его размер **16 GiB (17179869184 bytes)**;
> * количество секторов **33554432 sectors**;

![fdisk](images/P10_p001.png)

> Запускаем команду ` swapon --show ` .
> * swap (**1.9G**) - область на жестком диске, которая используется для временного хранения данных из оперативной памяти, для которых там больше нет места.

![swapon](images/P10_p002.png)

## Part 11. Использование утилиты df

Прочитать man по утилите df можно в этой [статье](https://www.opennet.ru/man.shtml?topic=df&category=1&russian=2 "man df").

> Запускаем команду ` df ` . Эта команда позволяет получить подробный отчёт об использовании дискового пространства системы. 

![df](images/P11_p001.png)

> Информация о корневом разделе (указывается в колонке *Mounted on* как ` / `):
> * размер раздела **16400252**
> * размер занятого пространства **6313176**
> * размер свободного пространства **9231988**
> * процент использования **41%**
> * единица измерения в выводе **kB**

> Запускаем команду ` df -Th` . Эта команда позволяет выводить тип системы и данные в удобочитаемом виде для человека.
> - ` -T ` (--print-type) - вывести тип файловой системы;
> - ` -h ` (--human-readable) - вывести размеры в удобочитаемом виде.

![df-Th](images/P11_p002.png)

> Для корневого раздела (/):
> * размер раздела **16G**
> * размер занятого пространства **6.1G**
> * размер свободного пространства **8.9G**
> * процент использования **41%**
> * тип файловой системы для раздела **ext4**

## Part 12. Использование утилиты du

> Для получения информации о приблизительном объёме дискового пространства, используемого указанными при вызове командами, файлами или каталогами, используем команду ` du `. У этой команды есть опции, но опишем только несколько из них:
> - ` -s ` - вывод общего размера папки; 
> - ` -h ` - для вывода в удобочитаемом виде;
> - Для вывода информации о папке необходимо прописать путь к ней.

![du](images/P12_p001.png)

> Выводим размер папок /home:

![du size home](images/P12_p002.png)

> Выводим размер папок /var:
 
![du size var](images/P12_p003.png)

> Выводим размер папок /var/log:

> ![du size var log](images/P12_p004.png)

> Для того чтобы вывести размер всего содержимого в каталоге ` /var/log `, используется команда: ` sudo du -ha /var/log/* ` .
> - ` -a ` - используется, если надо выводить размер не только папок, но и файлов, которые там находятся.

![du size var log all files](images/P12_p005.png)
![du size var log all files1](images/P12_p006.png)

## Part 13. Установка и использование утилиты ncdu 

> Для работы с утилитой необходимо ее установить с помощью команды: ` sudo apt install ncdu ` . Команда ` ncdu ` имеет то же назначение, что и du, но обладает более удобным интерфейсом. Для выхода из утилиты ` ncdu `  используется клавиша ` q `.

![ncdu install](images/P13_p001.png)

> Для вывода размера папки /home используем команду: ` ncdu /home ` .

![ncdu /home](images/P13_p002.png)

> Для вывода размера папки /var используем команду: ` ncdu /var ` .

![ncdu /var](images/P13_p003.png)

> Для вывода размера папки /var/log используем команду: ` ncdu /var/log ` .

![ncdu /var/log](images/P13_p004.png)

## Part 14. Работа с системными журналами 

> Открываем папки с помощью редактора **NANO**.

1. ` sudo nano /var/log/dmesg ` - драйвера устройств. Размер журнала ограничен, когда файл достигнет своего предела, старые сообщения будут перезаписаны более новыми.
 
![/var/log/dmesg](images/P14_p001.png)

2. ` sudo nano /var/log/syslog ` содержит глобальный системный журнал, в котором пишутся сообщения с момента запуска системы, от ядра Linux, различных служб, обнаруженных устройствах, сетевых интерфейсов и много другого.

![/var/log/syslog](images/P14_p002.png)

3. ` sudo nano /var/log/auth.log ` - информация об авторизации пользователей, включая удачные и неудачные попытки входа в систему, а также задействованные механизмы аутентификации.

![/var/log/auth.log](images/P14_p003.png)

![last auth](images/P14_p004.png)

> * Время последней успешной авторизации **12:42:37**.
> * Имя пользователя **genesiss**.
> * Метод входа в систему с паролем **systemd-logind**.

> Перезапускаем службу SSHd командой: ` sudo systemctl restart sshd ` . 

> Находим сообщение о рестарте службы в логах ` /var/log/syslog `

![sshd restart msg](images/P14_p005.png)

## Part 15. Использование планировщика заданий CRON

Подробнее про утилиту ` cron ` можно почитать в следующих статьях: [первая](https://ru.wikipedia.org/wiki/Cron "Wiki"), [второая](https://habr.com/ru/company/skillfactory/blog/656423/ "Cron — лучшие практики").

> **cron** — классический демон (компьютерная программа в системах класса UNIX), использующийся для периодического выполнения заданий в определённое время. Регулярные действия описываются инструкциями, помещенными в файлы crontab и в специальные каталоги.
> Файлы ` crontab `, создаваемые для отдельных пользователей, находятся в каталоге ` /usr/spool/cron/crontabs/ ` или ` /var/spool/cron/tabs/ `. Редактировать их вручную не рекомендуется, для этого используют команду: ` crontab -e `.
> Файлы crontab, используемые для управления всей системой, располагаются в каталоге ` /etc/cron.d/ `. Кроме того, в каталогах ` /etc/cron.daily/ `, ` /etc/cron.weekly/ ` и ` /etc/cron.monthly/ ` размещаются автоматически запускаемые программы (ежедневно, еженедельно или ежемесячно).
> Основной файл конфигурации cron: ` /etc/crontab `.

> ` uptime ` - утилита в UNIX-подобных системах, показывающая текущее время, время работы после загрузки, количество текущих пользователей в компьютерной системе и нагрузку за последние 1, 5 и 15 минут.

![uptime](images/P15_p001.png)

> Создаём задачу для планировщика заданий, чтобы он запускал утилиту ` uptime ` через каждые 2 минуты. Для того чтобы это осуществить, требуется отредактировать или создать файл рассписания для текущего пользователя. После открытия файла, задаем настройки для утилиты *uptime* : ` */2 * * * * uptime ` .

> Редактировать или создать файл рассписания можно с помощью команды: ` crontab -e ` . После введения этой команды откроется следующее окно, его уже можно редактировать.

![cron uptime 1](images/P15_p002.png)
![cron uptime 2](images/P15_p003.png)

> Таблица *crontab* состоит из 6 колонок, разделяемых пробелами или табуляторами. Первые пять колонок задают время выполнения (минута, час, день, месяц, день недели), в них может находиться число, список чисел, разделённых запятыми, диапазон чисел, разделённых дефисом, символы * или /. В системных файлах crontab после полей времени указывается пользователь, от которого запускается команда. Все остальные символы в строке интерпретируются как выполняемая команда с её параметрами. Если команда отправляет какой-нибудь текст в стандартный вывод, этот текст отправляется по e-mail пользователю.

> Спустя несколько минут проверяем записи в логах с помощью команды: `cat /var/log/syslog ` .

![cron uptime logs](images/P15_p004.png)

> Для удаления заданий из планировщика используем команду: ` crontab -r ` . Либо удаеляем задание из предыдущего файла, редактируя его с помощью той же команды: ` crontab -e ` .

![cron delete](images/P15_p005.png)
![cron delete](images/P15_p002.png)